/*
 *  Video Squirrel, a cross-platform movie cataloger
 *
 *  realmedia_reader.h
 *
 *  Copyright (C) Jory Stone - June 2003
 *  Copyright (C) Gabest - ?2003
 *
 *  Video Squirrel is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  Video Squirrel is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Video Squirrel; see the file COPYING.  If not, write to
 *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

/*!
	\file realmedia_reader.h
	\version \$Id$
	\brief a cross-platform movie cataloger
	\author Jory Stone            <jcsston @ toughguy.net>
	\author Gabest
*/

#include <stdio.h>
#include <string.h>
#include <fstream>

#define BYTE unsigned char
#define UINT8 unsigned char
#define UINT16 unsigned short
#define UINT32 unsigned long

#ifndef strcmpi
#define strcmpi strcmp
#endif

/// RealMedia_Properties.flags
#define PN_SAVE_ENABLED 0x0001										//< Allows clients to save a copy of the RealMedia file to disk.
#define PN_PERFECT_PLAY_ENABLED 0x0002						//< Allows clients to use extra buffering to ensure Perfect Play.
#define PN_LIVE_BROADCAST 0x0004									//< The RealMedia file is being generated by a live broadcast.

/// RealMedia_Media_Packet_Header.flags
#define PN_RELIABLE_FLAG 0x0001 //< If this flag is set, the packet is delivered reliably.
#define PN_KEYFRAME_FLAG 0x0002 //< If this flag is set, the packet is part of a key frame or in some way marks a boundary in your data stream. 

struct RealMedia_File_Header
{
	/// The unique object ID for a RealMedia File (.RMF). All RealMedia files begin with this identifier.
	char object_id[4];
	/// The size of the RealMedia header section in bytes.
	UINT32 size;
	/// The version of the RealMedia File Header object. All files created according to this specification have an object_version number of 0 (zero).
	UINT16 object_version;
	/// The version of the RealMedia file in PN Version format. All files created according to this specification have a major version number of 1. This member is present on all RealMedia_File_Header objects with an object_version of 0 (zero).
	UINT32 file_version;
	/// The number of headers in the header section that follow the RealMedia File Header. This member is present on all RealMedia_File_Header objects with an object_version of 0 (zero).
	UINT32 num_headers;
};

struct RealMedia_Properties
{
	//These are not needing, we assume an object_version of 0
	//char object_id[4];
	//UINT32    size;
	//UINT16    object_version;

	/// The maximum bit rate required to deliver this file over a network. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 max_bit_rate;
	/// The average bit rate required to deliver this file over a network. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 avg_bit_rate;
	/// The largest packet size (in bytes) in the media data. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 max_packet_size;
	/// The average packet size (in bytes) in the media data. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 avg_packet_size;
	/// The number of packets in the media data. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 num_packets;
	/// The duration of the file in milliseconds. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 duration;
	/// The number of milliseconds to pre-buffer before starting playback. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 preroll;
	/// The offset in bytes from the start of the file to the start of the index header object. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 index_offset;
	/// The offset in bytes from the start of the file to the start of the Data Section. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT32 data_offset;
	/// The number of media streams contained in the file. This member is present on all Properties objects with an object_version of 0 (zero).
	UINT16 num_streams;
	/// Flags indicating characteristics of the RealMedia file. Look at RealMedia_Properties.flags for values
	UINT16 flags;
};

struct RealMedia_Media_Properties
{
	//char object_id[4];
	//UINT32     size;
	//UINT16     object_version;

	UINT16 stream_number;
	UINT32 max_bit_rate;
	UINT32 avg_bit_rate;
	UINT32 max_packet_size;
	UINT32 avg_packet_size;
	UINT32 start_time;
	UINT32 preroll;
	UINT32 duration;
	UINT8 stream_name_size;
	char *stream_name;
	UINT8 mime_type_size;
	char *mime_type;
	UINT32 type_specific_len;
	char *type_specific_data;

  /// This one sort of applies to all a/v streams :P
	char *codec_name;
	
	//Logical file-info
	//This stuff goes in the RealMedia_Infomation_Field_List

	//Audio Stream
  UINT32 frequency;
  UINT8 channels;
  UINT8 codec_audience_number;

	//Video Stream
	UINT16 frame_width;
  UINT16 frame_height;
  float frame_rate;

};

struct RealMedia_Content_Description
{
	//char object_id[4];
	//UINT32     size;
	//UINT16      object_version;

	UINT16 title_len;
	char *title;
	UINT16 author_len;
	char *author;
	UINT16 copyright_len;
	char *copyright;
	UINT16 comment_len;
	char *comment;
};

struct RealMedia_Data_Chunk_Header
{
	/// The unique object ID for the Data Chunk Header ('DATA').
  UINT32 object_id;

	/// The size of the Data Chunk in bytes.
  UINT32 size;
	/// The version of the Data Chunk Header object.
  UINT16 object_version;
	/// Number of packets in the data chunk. This member is present on all Data Chunk Header objects with an object_version of 0 (zero).
  UINT32 num_packets; 
	/// Offset from start of file to the next data chunk. This field is not typically used. This member is present on all Data Chunk Header objects with an object_version of 0 (zero).
  UINT32 next_data_header;
};

struct RealMedia_Media_Packet_Header
{
	/// The version of the Media Packet Header object.
	UINT16 object_version;

	/// The length of the packet in bytes. This member is present on all Media Packet Header objects with an object_version of 0 (zero).
	UINT16 length;
	/// The 16-bit alias used to associate data packets with their associated Media Properties Header. This member is present on all Media Packet Header objects with an object_version of 0 (zero).
  UINT16 stream_number;
	/// The timestamp of the packet in milliseconds This member is present on all Media Packet Header objects with an object_version of 0 (zero).
  UINT32 timestamp;
	/// This is not used. This member is present on all Media Packet Header objects with an object_version of 0 (zero).
  UINT8 reserved; 
	/// Flags describing the properties of the packet. Look at RealMedia_Media_Packet_Header.flags for values
  UINT8 flags; 
	/// The application-specific media data. This member is present on all Media Packet Header objects with an object_version of 0 (zero).
  UINT8 *data; 
};


struct RealMedia_Packet
{
	/// The start of the raw packet data in the file
	UINT16 packet_start_pos;
	/// The length of the raw packet data in bytes
	UINT16 packet_data_length;
	
	/// The 16-bit alias used to associate data packets with their associated Media Properties Header
  UINT16 stream_number;
	/// The timestamp of the packet in milliseconds
  UINT32 timestamp;
	/// This is not used
  UINT8 reserved; 
	/// Flags describing the properties of the packet. Look at RealMedia_Media_Packet_Header.flags for values
  UINT8 flags; 	
	/// The application-specific media data.
	UINT8 *data; 
	//RealMedia_Packet *next_item;
};

struct RealMedia_Infomation_Field
{
	char *field_title;
	char *field_text;

	RealMedia_Infomation_Field *next_item;
};

class RealMedia_Infomation_Field_List
{
public:
	public:
	RealMedia_Infomation_Field_List();
	~RealMedia_Infomation_Field_List();
	int AddItem(RealMedia_Infomation_Field *new_item, bool bCheckIfExisting = true);	
	int GetListCount();
	RealMedia_Infomation_Field *operator[] (int requested_index);

protected:
	RealMedia_Infomation_Field *first_item;
};
class RealMedia_Reader
{
	public:
		RealMedia_Reader();
		~RealMedia_Reader();
		/// Processes a RealMedia file
		/// Call this first!
		/// \param filename The filename of the file to process
		/// \param bReadDataPackets If set to true the data packets are read and the headers stored
		/// \return 0 if successful		
		int Read(const char *filename, bool bPreReadDataPackets = false);
		BYTE *GetPacketData(RealMedia_Packet *packet_info);
		
		RealMedia_Packet *GetNextDataPacket();
		/// Get the length of the longest track
		/// \return The length of the longest track in milliseconds
		UINT32 GetLongestTrackLength();

		///Byte Swaping Function by Gabest
		void bswap(BYTE* s, int len);
		
	//Data members
		char *the_filename;
		FILE *real_media;
		RealMedia_File_Header the_header;
		RealMedia_Properties properties_block;

		//Used for both reading methods
		UINT32 packet_count;
		//Used for pre-reading method
		RealMedia_Packet* packet_array;
		//Used for on-the-fly reading method
		UINT32 current_packet_no;
		UINT32 packet_start_pos;
		UINT32 last_packet_start_pos;

		RealMedia_Media_Properties *media_properties_block[255];
		UINT8 media_properties_block_count;

		RealMedia_Infomation_Field_List field_list;

		RealMedia_Content_Description *content_description_block[255];
		UINT8 content_description_block_count;
};
